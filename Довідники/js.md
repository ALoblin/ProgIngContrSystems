# Java Script

[Современный учебник JavaScript](https://learn.javascript.ru/)



### Цикли while і for

Цикл **`while`** имеет следующий синтаксис:

```javascript
while (condition) {
  // код
  // также называемый "телом цикла"
}
```

Код из тела цикла выполняется, пока условие `condition` истинно. Например, цикл ниже выводит `i`, пока `i < 3`                     

```javascript
let i = 0;
while (i < 3) { // выводит 0, затем 1, затем 2
  alert( i );
  i++;
}
```

Одно выполнение тела цикла по-научному называется *итерация*. Цикл в примере выше совершает три итерации.

Если тело цикла состоит лишь из одной инструкции, мы можем опустить фигурные скобки `{…}`:                      

```javascript
let i = 3;
while (i) alert(i--);
```

Проверку условия можно разместить под телом цикла, используя специальный синтаксис **`do..while`**:

```javascript
do {
  // тело цикла
} while (condition);
```

Цикл сначала выполнит тело, а затем проверит условие `condition`, и пока его значение равно `true`, он будет выполняться снова и снова. Например:                     

```javascript
let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```

Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось **хотя бы один раз**, даже если условие окажется ложным. На практике чаще используется форма с предусловием: `while(…) {…}`.

Более сложный, но при этом самый распространённый цикл — цикл **`for`**.

```javascript
for (начало; условие; шаг) {
  // ... тело цикла ...
}
```

Цикл ниже выполняет `alert(i)` для `i` от `0` до (но не включая) `3`:  

```javascript
for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
  alert(i);
}
```

| часть     |            |                                                              |
| --------- | ---------- | ------------------------------------------------------------ |
| *начало*  | `i = 0`    | Выполняется один раз при входе в цикл                        |
| *условие* | `i < 3`    | Проверяется *перед* каждой итерацией цикла. Если оно вычислится в `false`, цикл остановится. |
| *шаг*     | `i++`      | Выполняется *после* тела цикла на каждой итерации *перед* проверкой условия. |
| *тело*    | `alert(i)` | Выполняется снова и снова, пока условие вычисляется в `true`. |

В целом, алгоритм работы цикла выглядит следующим образом:

```none
Выполнить *начало*
→ (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
→ (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
→ (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
→ ...
```

То есть, *начало* выполняется один раз, а затем каждая итерация заключается в проверке *условия*, после которой выполняется *тело* и *шаг*.

Вместо объявления новой переменной мы можем использовать уже существующую:                  

```javascript
let i = 0;
for (i = 0; i < 3; i++) { // используем существующую переменную
  alert(i); // 0, 1, 2
}
alert(i); // 3, переменная доступна, т.к. была объявлена снаружи цикла
```

**Пропуск частей `for` и `step`**

Любая часть `for` может быть пропущена. Для примера, мы можем пропустить `начало` если нам ничего не нужно делать перед стартом цикла.                      

```javascript
let i = 0; // мы уже имеем объявленную i с присвоенным значением
for (; i < 3; i++) { // нет необходимости в "начале"
  alert( i ); // 0, 1, 2
}
```

Можно убрать и `шаг`:                 

```javascript
let i = 0;
for (; i < 3;) {
  alert( i++ );
}
```

Это сделает цикл аналогичным `while (i < 3)`. А можно и вообще убрать всё, получив бесконечный цикл:

```javascript
for (;;) {
  // будет выполняться вечно
}
```

При этом сами точки с запятой `;` обязательно должны присутствовать, иначе будет ошибка синтаксиса.

**Прерывание цикла: «break»**

Обычно цикл завершается при вычислении *условия* в `false`. Но мы можем выйти из цикла в любой момент с помощью специальной директивы `break`. Например, следующий код подсчитывает сумму вводимых чисел до тех пор, пока посетитель их вводит, а затем – выдаёт:

```javascript
let sum = 0;
while (true) {
  let value = +prompt("Введите число", '');
  if (!value) break; // (*)
  sum += value;
}
alert( 'Сумма: ' + sum );
```

Директива `break` в строке `(*)` полностью прекращает выполнение цикла и передаёт управление на строку за его телом, то есть на `alert`.

**Переход к следующей итерации: continue**

Директива `continue` – «облегчённая версия» `break`. При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно `true`). Её используют, если понятно, что на текущем повторе цикла делать больше нечего.       

```javascript
 for (let i = 0; i < 10; i++) {
  // если true, пропустить оставшуюся часть тела цикла
  if (i % 2 == 0) continue;
  alert(i); // 1, затем 3, 5, 7, 9
}
```

Для чётных значений `i`, директива `continue` прекращает выполнение тела цикла и передаёт управление на следующую итерацию `for` (со следующим числом). Таким образом `alert` вызывается только для нечётных значений.

**`for..of`** Для массивов возможен и другой вариант цикла, `for..of`:                   

```javascript
let fruits = ["Яблоко", "Апельсин", "Слива"];
// проходит по значениям
for (let fruit of fruits) {
  alert( fruit );
}
```

Цикл `for..of` не предоставляет доступа к номеру текущего элемента, только к его  значению, но в большинстве случаев этого достаточно. А также это короче.

### Оператори порівняння

[javascript.ru](https://learn.javascript.ru/comparison)

- Больше/меньше: `a > b`, `a < b`.
- Больше/меньше или равно: `a >= b`, `a <= b`.
- Равно: `a == b`. Обратите внимание, для сравнения используется двойной знак равенства `=`. Один знак равенства `a = b` означал бы присваивание.
- Не равно. В математике обозначается символом `≠`. В JavaScript записывается как знак равенства с предшествующим ему восклицательным знаком: `a != b`.

Операторы сравнения, как и другие операторы, возвращают значение. Это значение имеет логический тип.

- `true` – означает «да», «верно», «истина».
- `false` – означает «нет», «неверно», «ложь».

Например:                

```javascript
alert( 2 > 1 );  // true (верно)
alert( 2 == 1 ); // false (неверно)
alert( 2 != 1 ); // true (верно)
```

Результат сравнения можно присвоить переменной, как и любое значение:            

```javascript
let result = 5 > 4; // результат сравнения присваивается переменной result
alert( result ); // true
```

Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный» или «лексикографический» порядок. Другими словами, строки сравниваются посимвольно.

```javascript
alert( 'Я' > 'А' ); // true
alert( 'Кот' > 'Код' ); // true
alert( 'Сонный' > 'Сон' ); // true
```

При сравнении значений разных типов JavaScript приводит каждое из них к числу. Например:                     

```javascript
alert( '2' > 1 ); // true, строка '2' становится числом 2
alert( '01' == 1 ); // true, строка '01' становится числом 1
```

Логическое значение `true` становится `1`, а `false` – `0`. Например:

```javascript
alert( true == 1 ); // true
alert( false == 0 ); // true
```

Возможна следующая ситуация:

- Два значения равны.
- Одно из них `true` как логическое значение, другое – `false`.

Например:

```javascript
let a = 0;
alert( Boolean(a) ); // false
let b = "0";
alert( Boolean(b) ); // true
alert(a == b); // true!
```

С точки зрения JavaScript, результат ожидаем. Равенство преобразует значения, используя числовое преобразование, поэтому `"0"` становится `0`. В то время как явное преобразование с помощью `Boolean` использует другой набор правил.

Использование обычного сравнения `==` может вызывать проблемы. Например, оно не отличает `0` от `false`:              

```javascript
alert( 0 == false ); // true
```

Та же проблема с пустой строкой:           

```javascript
alert( '' == false ); // true
```

Это происходит из-за того, что операнды разных типов преобразуются оператором `==` к числу. В итоге, и пустая строка, и `false` становятся нулём.

**Оператор строгого равенства `===` проверяет равенство без приведения типов.**

Другими словами, если `a` и `b` имеют разные типы, то проверка `a === b` немедленно возвращает `false` без попытки их преобразования.             

```javascript
alert( 0 === false ); // false, так как сравниваются разные типы
```

Ещё есть оператор строгого неравенства `!==`, аналогичный `!=`. Оператор строгого равенства дольше писать, но он делает код более очевидным и оставляет меньше мест для ошибок.

Поведение `null` и `undefined` при сравнении с другими значениями – особое:

- При строгом равенстве `===`

  Эти значения различны, так как различны их типы.                                                                                                                 `alert( null === undefined ); // false`

При нестрогом равенстве `==` Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.                   

```javascript
alert( null == undefined ); // true
```

- При использовании математических операторов и других операторов сравнения `< > <= >=`

  Значения `null/undefined` преобразуются к числам: `null` становится `0`, а `undefined` – `NaN`.

Посмотрим, какие забавные вещи случаются, когда мы применяем эти  правила. И, что более важно, как избежать ошибок при их использовании.

Сравним `null` с нулём:

```javascript
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```

С точки зрения математики это странно. Результат последнего сравнения говорит о том, что "`null` больше или равно нулю", тогда результат одного из сравнений выше должен быть `true`, но они оба ложны.

Причина в том, что нестрогое равенство и сравнения `> < >= <=` работают по-разному. Сравнения преобразуют `null` в число, рассматривая его как `0`. Поэтому выражение (3) `null >= 0` истинно, а `null > 0` ложно.

С другой стороны, для нестрогого равенства `==` значений `undefined` и `null` действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому (2) `null == 0` ложно.

Значение `undefined` несравнимо с другими значениями:         

```javascript
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

Почему же сравнение `undefined` с нулём всегда ложно?

На это есть следующие причины:

- Сравнения `(1)` и `(2)` возвращают `false`, потому что `undefined` преобразуется в `NaN`, а `NaN` – это специальное числовое значение, которое возвращает `false` при любых сравнениях.
- Нестрогое равенство `(3)` возвращает `false`, потому что `undefined` равно только `null` и ничему больше.

Просто относитесь к любому сравнению с `undefined/null`, кроме строгого равенства `===`, с осторожностью.

Не используйте сравнения `>= > < <=` с переменными, которые могут принимать значения `null/undefined`, если вы не уверены в том, что делаете. Если переменная может принимать эти значения, то добавьте для них отдельные проверки.