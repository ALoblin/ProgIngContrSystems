# Короткий довідник Java Script

[Посібник JavaScript MDN](https://developer.mozilla.org/uk/docs/Web/JavaScript/Guide), [яваскрипт.укр](http://яваскрипт.укр), [Современный учебник JavaScript](https://learn.javascript.ru/)

## Коментарі

Синтаксис коментарів такий самий, як в C++ та багатьох інших мовах програмування:

```js
// коментар для одного рядка 
/* довгий коментар
   на кілька рядків
 */
/* Однак, не можна /* змішувати коментарі */ SyntaxError */
```

## Робота з даними

### Змінні та константи

#### Оголошення (var,let,const)

Для створення змінної в JavaScript використовується ключове слово [`let`](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Statements/let). Оператор **`let`** оголошує локальну змінну блочної області видимості, з необов'язковим присвоєнням їй початкового значення.

Даний приклад створює (іншими словами: *об'являє* або *означує*) змінну з іменем «message», і поміщає в неї дані використовуючи оператор присвоювання `=` . Рядок збережеться в області пам'яті, зв'язаною зі змінною. Ми можемо отримати до неї доступ, використовуючи ім'я змінної. 

```javascript
let message1;
message = 'Hello'; // записати рядок в змінну
console.log(message1); // пише в консоль значення змінної
let message2 = 'Hello';//Можна суміщати об'явлення змінної і запис даних в один рядок.   
let user = 'John', age = 25, message = 'Hello';//можна кілька змінних об'являти в одному рядку
//або навіть так
let user1 = 'John',
  age1 = 25,
  message1 = 'Hello';
```

Областю видимості змінних, оголошених через **`let`**, є блок, у якому вони визначені, а також будь-які вкладені в нього блоки. У цьому сенсі **`let`** дуже схожий на **`var`**. Головна відмінність полягає в тому, що областю видимості змінної **`var`** є уся замикаюча функція.

На верхньому рівні програм та функцій **`let`**, на відміну від **`var`**, не створює властивості глобального об'єкта. 

Можна також використовувати інше ключове слово  [`var`](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Statements/var) замість `let`. Оголошення змінних через `var` обробляються до виконання будь-якого коду. Область видимості змінної, що її оголошено оператором `var`, залежить від *контексту виконання*, це або замикаюча функція, або — якщо змінну оголошено поза межами всіх функцій — глобальний контекст. Повторне оголошення змінної у JavaScript не скидає її значення. 

```javascript
var message = 'Hello';
```

**Оголошення `const`**  створює посилання на значення, доступне лише для читання. Що **не** гарантує незмінність значення, на котре вказує посилання, а лише той факт, що не можна повторно присвоїти будь-яке значення змінній з відповідним ім'ям.

#### Області видимості

Коли ви оголошуєте змінну за  межами будь-якої функції, вона називається глобальною змінною, оскільки  вона доступна для будь-якого іншого коду в поточному документі. Коли ви оголошуєте змінну в межах функції, вона називається локальною змінною, оскільки вона доступна лише в межах цієї функції. 

JavaScript версій, що передують ECMAScript 6, не має області [блокових операторів](https://developer.mozilla.org/uk/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#Block_statement); вірніше, змінна, оголошена у блокові, є локальною для *функції,* у якій знаходиться цей блок *(або глобальною змінною, якщо блок поза функціями у скрипті)*. Для прикладу розглянемо код, який буде записувати `5`, тому, що область видимості змінної `x` - функція (або глобальинй контекст), у якій оголошена функція `x`, а не блок оператора `if`.

```js
if (true) {
  var x = 5;
}
console.log(x);  // 5
```

Ця поведінка змінюється при використанні ключового слова `let`, введенного в ECMAScript 6.

```js
if (true) {
  let y = 5;
}
console.log(y);  // ReferenceError: y is not defined
```

Глобальні змінні фактично є властивостями глобальних об'єктів. На веб-сторінках глобальним об'єктом є [`window`](https://developer.mozilla.org/uk/docs/Web/API/Window), тому ви можете встановлювати та отримувати доступ до глобальних змінних за допомогою синтаксису `window.*variable*`.

Отже, ви можете отримати доступ до глобальних змінних оголошених в  одному вікні або фреймі з іншого вікна або фрейму, вказавши при цьому  ім'я цього вікна або фрейму. Наприклад, якщо в документі оголошена  змінна під назвою `phoneNumber`, ви можете звернутися до неї з фрейму `parent.phoneNumber`.

### Типи даних та літерали

Змінна в JavaScript може містити будь-які дані. У один момент там може бути рядок, а в інший – число. Коли змінна не прив'язується до конкретного типу, але при цьому типи даних існують, це називається "динамічною типізацією". 

```javascript
// не буде помилкою
let message = "hello";
message = 123456;
```

В JS існує вісім типів даних: `number`, `BigInt`, `string`, `boolean`, `null`, `undefined`, `object`, `symbol` 

#### number

Числовий тип даних (`number`) представляють собою як цілочисельні значення, так і числа з  плаваючою комою. Крім звичайних чисел (`15` чи  `36.6`) існують спеціальні числові значення: `Infinity` (нескінченність), `-Infinity` і `NaN` (не число).

```js
console.log(1+2);//видасть 3
console.log(1.1+2.1);//видасть 3.2
console.log("2"+3);//видасть "23"
console.log("два"+3);//видасть "два3"
console.log(2/"0.5");//видасть 4
console.log("два"/3);//видасть NaN
console.log(1/0);//видасть Infinity
```

Цілочисельні літерали типів [`Number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number) та [`BigInt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) можна виразити у різних формах, в залежності від першої літери: 10-ковій (без літери), всімковій (`0o`), 16-ковій (`0x`), 2-вій (`0b`), наприклад: 

```js
console.log(-345);		//-345
console.log(-0o77);		//-63
console.log(-0xF1A7);	//-61863
console.log(-0b11);		//-3
```

Літерали з плаваючою комою можуть задаватися у різному форматі:

```js
console.log(3.1415926);	//3.1415926
console.log(-.123456789);//-0.123456789
console.log(-3.1E+12);	//-3100000000000
console.log(.1e-3);		//0.0001
```

#### BigInt

У JavaScript тип `number` не може містити більше, ніж `2^53` (два в степені 53), або менше, ніж `-2^53` для від'ємних. Це технічне обмеження викликає їх внутрішнє представлення. `2^53` - це досить велике число. Але іноді нам потрібні дійсно гігантські числа, наприклад в криптографії або при використанні мітки часу («timestamp») з мікросекундами. Тип `BigInt` був доданий в JavaScript, щоб дати можливість працювати з цілими числами довільної довжини. Щоб створити значення типу `BigInt`, необхідно додати `n` в кінець числового літералу:

```javascript
// символ "n" в кінці значить, що це BigInt
const bigInt = 1234567890123456789012345678901234567890n;
console.log(-345n);//-345n
console.log(-0o77n);//-63n
console.log(-0xF1A7n);//-61863n
console.log(-0b11n);//-3n
```

#### string

Рядок (`string`) в JavaScript повинен бути взятий в лапки.

```javascript
let str = "Рядок в двойнищ лапках";
let str2 = 'Можна використовувати одинарні лапки';
let phrase = `Зворотні лапки (зліва від '1') дозволяють вставляти значення змінних ${str}, інші лапки таке не дозвоялють робити`;
```

Крім звичайних символів, ви можете також включати до рядків спеціальні символи, як показано в наступному прикладі.

```js
"one line \n another line"
```

У наступній таблиці перераховані спеціальні символи, які можна використовувати в рядках JavaScript.

| Character     | Meaning                                                      |
| ------------- | ------------------------------------------------------------ |
| `\0`          | Null Byte                                                    |
| `\b`          | Backspace                                                    |
| `\f`          | Form feed                                                    |
| `\n`          | New line                                                     |
| `\r`          | Carriage return                                              |
| `\t`          | Tab                                                          |
| `\v`          | Vertical tab                                                 |
| `\'`          | Apostrophe or single quote                                   |
| `\"`          | Double quote                                                 |
| `\\`          | Backslash character                                          |
| `\*XXX*`      | The character with the Latin-1 encoding specified by up to three octal digits *XXX* between 0 and 377. For example, \251 is the octal sequence for the copyright symbol. |
| `\x*XX*`      | The character with the Latin-1 encoding specified by the two hexadecimal digits *XX* between 00 and FF. For example, \xA9 is the hexadecimal sequence for the copyright symbol. |
| `\u*XXXX*`    | The Unicode character specified by the four hexadecimal digits *XXXX*. For example, \u00A9 is the Unicode sequence for the copyright symbol. See [Unicode escape sequences](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Lexical_grammar#String_literals). |
| `\u*{XXXXX}*` | Unicode code point escapes. For example, \u{2F804} is the same as the simple Unicode escapes \uD87E\uDC04. |

Наприклад

```js
var quote = "He read \"The Cremation of Sam McGee\" by R.W. Service.";
console.log(quote);// He read "The Cremation of Sam McGee" by R.W. Service.
var home = "c:\\temp";
console.log(home);// c:\temp
```

Ви також можете уникнути розривів ліній, передуючи їм зворотньою  косою. Зворотня коса та розрив рядків видаляються зі значення рядка.

```js
var str = "цей текст\
розірваний \
між кількома \
рядками."
console.log(str);   // цей текст розірваний між кількома рядками.
```

```js
var poem = 
"Roses are red,\n\
Violets are blue.\n\
I'm schizophrenic,\n\
And so am I."
```

#### boolean

Булевий тип (`boolean`) може приймати значення: `true` (істина) і `false` (хибність). Можуть бути результатом порівняння 

```javascript
let isGreater = 4 > 1;
console.log(isGreater); // буде true 
let a = true; // булевий літерал
```

#### null 

Це тип і значення `null`, що значить `нічого`

```javascript
let age = null;
```

#### undefined

Значення `undefined` - значить, що змінній не було присвоєне значення                       

```javascript
let x;
console.log(x); // виведе "undefined"
```

#### function

Тип змінної `function` не існує.



#### object

Детальніше про роботу з обєктами можна почитати [тут](jsobjects.md).

`object` - у JavaScript є колекції **властивостей** і **методів**. Методом  називається функція, яка є членом об'єкта. Властивість є значення або  набір значень (у вигляді масиву або об'єкта), який є членом об'єкта і  може містити будь який тип даних.

Конструктор `Object` створює об'єкт-обгортку для переданого значення.  Якщо значенням є `null` або `undefined`, створює і повертає порожній об'єкт, в іншому випадку повертає об'єкт такого типу, який відповідає  переданому значенню.

 JavaScript підтримує 4 типи об'єктів:

- внутрішні об'єкти, такі як [Array](http://xn--80adth0aefm3i.xn--j1amh/Array) і [String](http://xn--80adth0aefm3i.xn--j1amh/String);
- створені об'єкти за допомогою конструктора або [функції-конструктор](http://xn--80adth0aefm3i.xn--j1amh/функція-конструктор);
- об'єкти базового середовища, такі як [window](http://xn--80adth0aefm3i.xn--j1amh/window) і [document](http://xn--80adth0aefm3i.xn--j1amh/document);
- об'єкти ActiveX.

Обєкт можна створити через конструктор, або через літерал

```javascript
let user = new Object(); // синтаксис "конструктор об'єкта"
let user = {};  // синтаксис "літерал об'єкта"
```

Об'єктні літерали - це список з нуля або більше пар імен властивостей та асоційованих значень об'єкту, взятих у фігурні дужки (`{}`). **Не використовуйте об'єктні літерали на початку інструкції!** Це призведе до помилки (або не поводитиметься так, як ви очікували), оскільки `{` буде інтерпретуватися як початок блоку.

Властивості, які також називають **полями**,  мають ключ, який також називають **ім'ям** або **ідентифікатором**.  Використовуючи літеральний синатксис об'явлення ми можемо одразу в об'єкт помістити кілька властивостей через пару "ключ : значення".  Значення може бути будь якого типу, в тому числі об'єктом. Доступ до властивостей може проводитися через крапку. Наприклад: 

```js
var sales = 'Toyota';
function carTypes(name) {
  if (name === 'Honda') {
    return name;
  } else {
    return "Sorry, we don't sell " + name + ".";
  }
}
var car = { myCar: 'Saturn', getCar: carTypes('Honda'), special: sales };
console.log(car.myCar);   // Saturn
console.log(car.getCar);  // Honda
console.log(car.special); // Toyota 
```

Видалення властивостей проводитсья через `delete`

```javascript
delete user.age;
```

Крім того, ви можете використовувати числовий або  рядковий літерал для назви властивості або вкладати об'єкт всередину  іншого. У наступному прикладі використовуються ці можливості.

```js
var car = { manyCars: {a: 'Saab', b: 'Jeep'}, 7: 'Mazda' };
console.log(car.manyCars.b); // Jeep
console.log(car[7]); // Mazda
```

Імена властивостей об'єкта можуть бути будь-якими  рядками, включаючи порожні. Якщо ім'я властивості не є дійсним ідентифікатором (не за правилами найменування змінних, наприклад включає пробіли) чи числом JavaScript, воно повинно бути вставлено в  лапки. До імен властивостей, які не є дійсними ідентифікаторами, не можна отримати доступ до властивості через крапку (`.`), але *можна* можна це зробити через квадартін лапки ("`[]`").

```js
var unusualPropertyNames = {
  '': 'An empty string',
  '!': 'Bang!'
}
console.log(unusualPropertyNames.'');   // SyntaxError: Unexpected string
console.log(unusualPropertyNames['']);  // An empty string
console.log(unusualPropertyNames.!);    // SyntaxError: Unexpected token !
console.log(unusualPropertyNames['!']); // Bang!
```

Доступ через квадратні лапки також дає можливість доступатися до властивостей об'єкту через змінну або вираз. 

```javascript
let key = "likes birds";
user[key] = true; // те саме, що і user["likes birds"] = true;

let fruit = prompt("Який фрукт купити?", "apple");
let bag = {
  [fruit]: 5, // ім'я властивості буде взято зі змінної fruit 
};
```

 Якщо необхідно властивості надавати значення з тим самим іменем, його можна не вказувати:

```javascript
function makeUser(name, age) {
  return {
    name, // те саме, що і name: name
    age   // те саме, що і age: age
    // ...
  };
}
```

Перевірка властивостей продиться через оператор [`in`](#in)

Перебір усіх властивостей проводитьс через [`for..in`](#forin)

Присвоєння для обєктів працює як копіювання за посиланням на той же об`єкт.

Порівняння обєктних змінних `==` або `===` показує, що ці змінні посилаються на той же обєкт.

 

#### array (масив)

Літерали масивів, це список від нуля та більше, кожен з елементів  якого представляє елемент масиву, вкладений у квадратні дужки (`[]`). Коли ви створюєте масив використовуючи літерал масиву, він  ініциалізується зі вказаним значенням, як її елемент, а його довжина  залежить від кількості вказаних аргументів.

Наступний приклад показує створення масиву `coffees` з трьох елементів, та довжиною в три:

```js
var coffees = ["French Roast", "Colombian", "Kona"];
```

**Зауважте:** Літерал масиву - це тип ініціалізатора об'єктів. Див [Using Object Initializers](https://developer.mozilla.org/uk/docs/Web/JavaScript/Guide/Working_with_Objects#Using_object_initializers).

Якщо масив створюється за допомогою літералів у скрипті верхнього  рівня, JavaScript інтерпретує масив кожного разу, коли він оцінює вираз, що містить літерал масиву. На додаток, літерал використовується у  функції та створюється кожного разу коли викликається функція.

**Зауважте:** Крім літералів масиву є ще `Array` objects (масиви об`єктів). Дивись [`Array`](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Global_Objects/Array) та [Indexed collections](https://developer.mozilla.org/uk/docs/Web/JavaScript/Guide/Indexed_collections) та більши детально про `Array` objects.

Вам не потрібно в літералі масиву вказувати всі елементи. Якщо Ви помістите дві коми в ряд, масив створюється з `undefined` для не визначених елементів. Наступний приклад створює масив `fish` :

```js
var fish = ["Lion", , "Angel"];
```

Цей масив має два елементи зі значеннями та один порожній елемент:

- `fish[0]` - "Lion",
- `fish[1]` - `undefined`
- `fish[2]` - "Angel").

Якщо в кінці списку елементів ви додаєте кінцеву кому, кома ігнорується.

У наступному прикладі довжина масиву дорівнює трьом. Не існує `myList[3]`. Усі інші коми в списку вказують на новий елемент.

**Зауважте:** Послідовні коми можуть створювати помилки в старих версіях веб-браузерів, тому краще їх видаляти.

```js
var myList = ['home', , 'school', ];
```

У наступному прикладі довжина масиву становить чотири, а `myList[0]` та `myList[2]` відсутні.

```js
var myList = [ , 'home', , 'school'];
```

У наступному прикладі довжина масиву становить чотири, а `myList[1]` та `myList[3]` відсутні. **Ігнорується лише остання кома**.

```js
var myList = ['home', , 'school', , ];
```

Розуміння поведінки додаткових ком важливо для розуміння JavaScript  як мови, однак при написанні власного коду явне оголошення пропущених  елементів, як `undefined` , підвищить чіткість та налагоджуваність вашого коду.



#### symbol

Тип `symbol` (символ) наряду з типом `string` використовується для створення ідентифікаторів властивостей об'єктів. Однак символи є унікальними ідентифікаторами.  

```javascript
// Створюємо новий символ id
let id = Symbol();
let user = {
  name: "Вася",
  age: 30,
  [id]: 123
};
console.log (user[id]);
```

Є також глобальні символи, системні символи доступні через глобальний об'єкт `Symbol`. 

#### Оператор typeof{#typeof}

Оператор `typeof` повертає тип аргумента. Він працює однаково з довма синтаксисами

```js
typeof операнд
typeof (операнд)
```

```javascript
console.log (typeof undefined);// "undefined"
console.log (typeof 0) ;// "number"
console.log (typeof 1n); // "bigint"
console.log (typeof true); // "boolean"
console.log (typeof "foo"); // "string"
console.log (typeof Symbol("id")); // "symbol"
conso;e.log (typeof (['Я','М']));//"object", бо масиви це об'єкти
console.log (typeof Math); // "object" - так як Math вбудований в JS обєкт для роботи з мат.операціями
console.log (typeof null); // "object" - хоч це не так
console.log (typeof console.log); // "function" - хоч формально такого типу немає, для методів і функцій поертається "function"
```







### Перетворення типів

Найчастіше оператори і функції автоматично перетворюють передані їм значення (примітвиного типу) до потрібного типу. Наприклад, `console.log` автоматично перетворює будь-яке значення до рядка. Математичні оператори перетворюють значення до чисел. Але в випадки, коли нам потрібно явно перетворити значення в очікуваний тип.

#### В string

Можна використовувати функцію `String (value)`, щоб явно перетворити значення до рядка:              

```javascript
let value = true;
console.log (typeof value); // boolean
value = String(value); // тепер це рядок "true"
console.log (typeof value); // string
```

#### В Number

Можна використати функцію `Number(value)`, щоб явно перетворити `value` в число. Якщо рядок не може бути перетверений в число, результатом буде `NaN`.

```javascript
let str = "123"; console.log(typeof str); // string
let num = Number(str); console.log(typeof num); // стає числом 123, тому number
let age = Number("Будь який рядок без числа"); console.log(age); // NaN, перетворення не вдалося
console.log(Number("   123   ") ); // 123
console.log(Number("123z") );      // NaN (помилка читання числа в "z")
console.log(Number(true) );        // 1
console.log(Number(false) );       // 0
```

Почти усі математичні оператори иконують чисельне перетворення, за виключенням  `+`. Якщо один із доданків є рядком, тоді всі інші приводться до рядків і робиться конкатинація (зєднання).                     

У випадку, коли значення, що представляє число, знаходиться в пам'яті як рядок, існують методи для перетворення [`parseInt()`](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Global_Objects/parseInt) та [`parseFloat()`](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/parseFloat). 

`parseInt` повертає тільки цілі числа, тому його використання обмежується десятковими знаками. Окрім того, найкращою практикою для `parseInt` завжди є включення параметра radix. Параметр radix використовується для визначення чисельної системи, яка буде використовуватися.

```js
let a='10'; console.log (parseInt(a,10));//10, бо база 10-кова
let b='10'; console.log (parseInt(b,16));//16, бо база 16-кова
let c='10'; console.log (parseInt(c,2));//2, бо база 2-кова
let d='10ttf'; console.log (parseInt(d,16));//16
```

```js
let a='10.1'; console.log (parseFloat(a));//10.1
let b='1e+2'; console.log (parseFloat(b));//100
let c='.456'; console.log (parseFloat(c));//0.456
let d='0,456'; console.log (parseFloat(d,16));//0
let e='4.5ffff.34'; console.log (parseFloat(e,16));//4.5
```

Альтернативним способом отримання числа з рядка є оператор `+` (одинарний плюс):

```js
"1.1" + "1.1" = "1.11.1"
(+"1.1") + (+"1.1") = 2.2   
```

#### В Boolean                    

```javascript
console.log(Boolean(1)); // true
console.log(Boolean(0)); // false
console.log(Boolean("Привіт!")); // true
console.log(Boolean("")); // false
console.log(Boolean("0")); // true
console.log(Boolean(" ")); // пробіл це також true (любий непустий рядок це true)
```



### Оператори

[developer.mozilla.org](https://developer.mozilla.org/uk/docs/Web/JavaScript/Guide/%D0%92%D0%B8%D1%80%D0%B0%D0%B7%D0%B8_%D1%82%D0%B0_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B8)

- *Операнд* – то, до чого застосовується оператор. Наприклад, у множенні `5 * 2` є два операнди: лівий операнд дорівнює `5`, а правий операнд дорівнює `2`. Інколи їх називають «аргументами» замість «операндів».
- *Унарним* називається оператор, котрий застосовується до одного операнда. Наприклад, оператор унарний мінус `"-"` змінює знак числа на протилежний:

```javascript
let x = 1;
x = -x;
console.log(x); // -1, применили унарный минус
```

- *Бінарним* називається оператор, котрий застосовується до двох операндів. Той же мінус існує і в бінарній формі:

```javascript
let x = 1, y = 3;
console.log( y - x ); // 2, бінарний мінус
```

#### Присвоєння (=)

Лівосторонньому операнду `=` дається значення правостороннього виразу.

```javascript
let x = 2 * 2 + 1;
console.log(x); // 5
let a, b, c;
a = b = c = 2 + 2;//присвоєння ланцюжком, усім змінним буде присвоєно 4
let a1 = 1;//1
let b1 = 2;//2
let c1 = 3 - (a1 = b1 + 1);//0
```

Для об'єктів присвоюється не значення  копіюється посилання. Тобто 

```javascript
let user = { name: "John" };
let admin = user; // це друга змінна, яка посилається на той же об'єкт
```

 

#### Оператори порівняння

[Оператор порівняння](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/Оператори_порівняння) порівнює свої операнди та повертає логічне значення, базуючись на істинності  порівняння. Операнди можуть бути числовими, рядковими, логічними  значеннями або об'єктами. Рядки порівнюються згідно стандартного  лексикографічного порядку, з використанням значень Unicode. У більшості  випадків, якщо два операнди не належать до одного типу, JavaScript  намагається привести їх до належного для порівняння типу. Зазвичай це  призводить до числового порівняння операндів. Єдиними винятками у  конвертації типів під час порівняння є оператори `===` та `!==`, які виконують перевірку на строгу рівність та строгу нерівність. Ці  оператори не намагаються перед перевіркою на рівність привести операнди  до спільного типу. Наступна таблиця наводить оператори порівняння у  контексті цього фрагменту коду:

```js
var var1 = 3;
var var2 = 4;
```

| Оператор                                                     | Опис                                                         | Приклади, які повертають true              |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------ |
| [Рівність](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/Оператори_порівняння#Рівність) (`==`) | Повертає `true`, якщо оператори рівні.                       | `3 == var1`    `"3" == var1`    `3 == '3'` |
| [Нерівність](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/Оператори_порівняння#Нерівність_!) (`!=`) | Повертає `true`, якщо оператори нерівні.                     | `var1 != 4    var2 != "3"`                 |
| [Строга рівність](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/Оператори_порівняння#Ідентичність_строга_рівність) (`===`) | Повертає `true` якщо оператори рівні та належать до одного типу. Дивіться також [`Object.is`](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/is) та [однаковість у JS](https://developer.mozilla.org/uk/docs/Web/JavaScript/Перевірка_на_рівність_та_однаковість). | `3 === var1`                               |
| [Строга нерівність](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/Оператори_порівняння#Неідентичність_строга_нерівність_!) (`!==`) | Повертає `true`, якщо оператори належать до одного типу, але нерівні, або належать до різних типів. | `var1 !== "3"    3 !== '3'`                |
| [Більше ніж](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/Оператори_порівняння#Більше_ніж_>) (`>`) | Повертає `true`, якщо лівий операнд більший за правий.       | `var2 > var1    "12" > 2`                  |
| [Більше чи дорівнює](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/Оператори_порівняння#Більше_чи_дорівнює_>) (`>=`) | Повертає `true`, якщо значення лівого операнда більше або дорівнює значенню правого операнда. | `var2 >= var1    var1 >= 3`                |
| [Менше ніж](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/Оператори_порівняння#Менше_ніж_<) (`<`) | Повертає `true`, якщо лівий операнд менший за правий.        | `var1 < var2    "2" < 12`                  |
| [Менше чи дорівнює](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/Оператори_порівняння#Менше_чи_дорівнює_<) (`<=`) | Повертає `true`, якщо значення лівого операнда менше або дорівнює значенню правого операнда. | `var1 <= var2    var2 <= 5`                |

**Заувага:** (**=>**) не оператор, а позначення для [стрілкових функцій](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Functions/Стрілкові_функції).

#### Арифметичні оператори

[Арифметичний оператор](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators) приймає числові значення (літерали чи змінні) в якості операндів та повертає єдине числове  значення. Стандартними арифметичними операторами є додавання (`+`), віднімання (`-`), множення (`*`) та ділення (`/`). Ці оператори працюють так само, як і в більшості інших  мов програмування при використанні з числами з рухомою комою (зокрема,  зауважте, що ділення на нуль повертає [`Infinity`](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Global_Objects/Infinity)). Додаткові арифметичні оператори:

| Оператор                     | Опис                                                         | Приклад                                                      |
| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Остача(`%`)                  | Бінарний оператор. Повертає цілочисельну остачу від ділення двох операндів. | `12 % 5` повертає 2.                                         |
| Інкремент (`++`)             | Унарний оператор. Додає до операнда одиницю. Якщо використовується як префіксний оператор (`++x`), повертає значення операнда після додавання одиниці; якщо використовується як постфіксний оператор (`x++`), повертає значення операнда перед додаванням одиниці. | Якщо `x` дорівнює 3, тоді `++x` присвоює `x` значення 4 та повертає 4, в той час, як `x++` повертає 3 і лише тоді присвоює `x` значення 4. |
| Декремент (`--`)             | Унарний оператор. Віднімає одиницю від свого операнда. Повернене значення аналогічне поверненому значенню оператора інкременту. | Якщо `x` дорівнює 3, тоді `--x` присвоює `x` значення 2 та повертає 2, в той час, як `x--` повертає 3 і тільки тоді присвоює `x` значення 2. |
| Унарний мінус (`-`)          | Унарний оператор. Повертає операнд з протилежним знаком.     | Якщо `x` дорівнює 3, то `-x` повертає -3.                    |
| Унарний плюс (`+`)           | Унарний оператор. Намагається перетворити операнд на число, якщо він не є числом. | `+"3"` повертає `3`.     `+true` повертає `1.`               |
| Піднесення до степеня (`**`) | Підносить `основу степеня` до `показника` степеня, тобто, `основапоказник` | `2 ** 3` повертає `8`.     `10 ** -1` повертає `0.1`.        |

#### Бітові оператори

[Бітовий оператор](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators) опрацьовує свої операнди як послідовність 32-х бітів (нулів та одиниць), а не як  десяткові, шістнадцяткові або вісімкові числа. Наприклад, десяткове  число дев'ять має бітове представлення 1001. Бітові оператори виконують  операції над цими бітовими представленнями, але повертають стандартні  числові значення JavaScript. Наступна таблиця наводить перелік бітових операторів JavaScript.

| Оператор                          | Застосування | Опис                                                         |
| --------------------------------- | ------------ | ------------------------------------------------------------ |
| Побітове І (AND)                  | `a & b`      | Повертає одиницю на кожній позиції, де відповідні біти обох операндів дорівнюють одиницям. |
| Побітове АБО (OR)                 | `a | b`      | Повертає нуль на кожній позиції, де відповідні біти обох операндів дорівнюють нулям. |
| Виключне побітове АБО (XOR)       | `a ^ b`      | Повертає нуль на кожній позиції, де відповідні біти однакові.     [Повертає один на кожній позиції, де відповідні біти мають різні значення.] |
| Побітове НЕ (NOT)                 | `~ a`        | Виконує інверсію бітів операнду.                             |
| Лівий зсув                        | `a << b`     | Зсуває `a` у двійковому представленні на `b` бітів ліворуч, заповнюючи позиції справа нулями. |
| Правий зсув з розширенням знаку   | `a >> b`     | Зсуває `a` у двійковому представленні на `b` бітів праворуч, відкидаючи зсунуті біти. |
| Правий зсув із заповненням нулями | `a >>> b`    | Зсуває `a` у двійковому представленні на `b` бітів праворуч, відкидаючи зсунуті біти та заповнюючи позиції зліва нулями. |

Концептуально побітові логічні оператори працюють наступним чином:

- Операнди перетворюються на 32-бітні цілі числа та виражаються  послідовністю бітів (нулів та одиниць). Числа, що мають більше 32 бітів, втрачають свої старші біти. Наприклад, наступне ціле число, що має  більше 32 бітів, буде перетворено на 32-бітне ціле число:  

  ```html
  До:     11100110111110100000000000000110000000000001
  Після:              10100000000000000110000000000001
  ```

-  Кожен біт першого операнду ставиться у пару до відповідного біту  другого операнду: перший біт до першого біту, другий біт до другого, і  так далі.
- Оператор застосовується до кожної пари бітів, а результат будується побітово. Наприклад, бінарним представленням числа дев'ять є 1001, а бінарним  представленням п'ятнадцяти є 1111. Отже, коли бітові оператори  застосовуються до цих величин, результати будуть наступні:

| Вираз    | Результат | Двійковий опис                                               |
| -------- | --------- | ------------------------------------------------------------ |
| `15 & 9` | `9`       | `1111 & 1001 = 1001`                                         |
| `15 | 9` | `15`      | `1111 | 1001 = 1111`                                         |
| `15 ^ 9` | `6`       | `1111 ^ 1001 = 0110`                                         |
| `~15`    | `-16`     | `~``00000000...``00001111 = ``1111``1111``...``11110000`     |
| `~9`     | `-10`     | `~``00000000``...``0000``1001 = ``1111``1111``...``1111``0110` |

Зауважте, що усі 32 біти інвертуються побітовим оператором НЕ, і що  значення, в яких найстарший (перший зліва) біт дорівнює 1, відображають  від'ємні числа (формат доповняльного коду).

Оператори бітового зсуву приймають два операнди: перший є величиною, в якій треба виконати зсув, а другий вказує кількість бітових позицій для зсуву. Напрямок операції зсуву контролюється застосованим оператором. Оператори зсуву перетворюють свої операнди на 32-бітні цілі числа та  повертають результат того самого типу, до якого належить лівий операнд.

| Оператор                                 | Опис                                                         | Приклад                                                      |
| ---------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Лівий зсув     (`<<`)                    | Цей оператор виконує зсув першого операнду на вказану кількість  бітів ліворуч. Надлишкові біти, зсунуті ліворуч, відкидаються. Біти,  додані справа, заповнюються нулями. | `9<<2` вертає 36, тому що число 1001, зсунуте на 2 біти ліворуч, стає 100100, тобто, 36. |
| Правий зсув з розширенням знаку (`>>`)   | Цей оператор виконує зсув першого операнду на вказану кількість  бітів праворуч. Надлишкові біти, зсунуті праворуч, відкидаються. Біти,  додані зліва, заповнюються значенням старшого біта. | `9>>2` вертає 2, тому що число 1001, зсунуте на 2 біти праворуч, стає 10, тобто 2. Аналогічно, `-9>>2` вертає -3, тому що знак зберігається. |
| Правий зсув із заповненням нулями(`>>>`) | Цей оператор виконує зсув першого операнду на вказану кількість  бітів праворуч. Надлишкові біти, зсунуті праворуч, відкидаються. Біти,  додані зліва, заповнюються нулями. | `19>>>2` вертає 4, тому що число 10011,  зсунуте на 2 бітів праворуч, стає 100, тобто 4. Для невід'ємних чисел,  правий зсув із заповненням нулями та правий зсув з розширенням знаку  дають однаковий результат. |

#### Логічні оператори

[Логічні оператори](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/Logical_Operators) застосовуються до булевих (логічних) значень; в цьому випадку вони повертають значення типу Boolean. Однак, оператори `&&` та `||` насправді повертають значення одного з заданих операндів, тому, якщо ці оператори використовуються зі значеннями не булевого типу, вони повернуть  значення не булевого типу. Логічні оператори описані у наведеній нижче  таблиці.

| Оператор          | Застосування     | Опис                                                         |
| ----------------- | ---------------- | ------------------------------------------------------------ |
| Логічне І (`&&`)  | `expr1 && expr2` | Вертає вираз `expr1`, якщо він може бути перетворений на `false`; інакше, повертає `expr2`. Таким чином, при використанні з булевими значеннями `&&` вертає `true`, якщо обидва операнди дорівнюють true; інакше, вертає `false`. |
| Логічне АБО(`||`) | `expr1 || expr2` | Вертає вираз `expr1`, якщо він може бути перетворений на `true`; інакше, вертає `expr2`. Таким чином, при використанні з булевими значеннями `||` вертає `true`, якщо будь-який з операндів дорівнює true; якщо обидва дорівнюють false, вертає `false`. |
| Логічне НЕ(`!`)   | `!expr`          | Вертає `false`, якщо його єдиний операнд може бути перетворений на `true`; інакше, вертає `true`. |

Прикладами виразів, які можуть бути перетворені на `false`, є ті, які повертають null, 0, NaN, порожній рядок ("") або undefined. Наступний код демонструє приклади оператора `&&` (логічне І).

Оскільки логічні вирази обчислюються зліва направо, вони  перевіряються на можливе "коротке замикання" обчислення за наступними  правилами:

- `false` && *будь-що* обчислюється як false.
- `true` || *будь-що* обчислюється як true.

Правила логіки гарантують, що ці обчислення завжди будуть правильними. Зауважте, що частина виразу *будь-що* не обчислюється, тому будь-які побічні ефекти від цих обчислень не відбудуться.

```js
var a1 =  true && true;     // t && t вертає true
var a2 =  true && false;    // t && f вертає false
var a3 = false && true;     // f && t вертає false
var a4 = false && (3 == 4); // f && f вертає false
var a5 = 'Кіт' && 'Пес';    // t && t вертає Пес
var a6 = false && 'Кіт';    // f && t вертає false
var a7 = 'Кіт' && false;    // t && f вертає false
```

Наступний код демонструє приклади оператора `||` (логічне АБО).

```js
var o1 =  true || true;     // t || t вертає true
var o2 = false || true;     // f || t вертає true
var o3 =  true || false;    // t || f вертає true
var o4 = false || (3 == 4); // f || f вертає false
var o5 = 'Кіт' || 'Пес';    // t || t вертає Кіт
var o6 = false || 'Кіт';    // f || t вертає Кіт
var o7 = 'Кіт' || false;    // t || f вертає Кіт
```

Наступний код демонструє приклади оператора `!` (логічне НЕ).

```js
var n1 = !true;  // !t вертає false
var n2 = !false; // !f вертає true
var n3 = !'Кіт'; // !t вертає false
```

#### Рядкові оператори

На додачу до операторів порівняння, які можуть застосовуватись до  рядкових значень, оператор конкатенації (+) об'єднує значення двох  рядків, повертаючи інший рядок, який є об'єднанням рядків двох  операндів. Наприклад,

```js
console.log('мій ' + 'рядок'); // консоль виводить рядок "мій рядок".
```

Скорочений оператор присвоєння += також може застосовуватись для конкатенації рядків. Наприклад,

```js
var mystring = 'алфа';
mystring += 'віт'; // повертає "алфавіт" та присвоює це значення mystring.
```

#### Умовний (тернарний) оператор

[Умовний оператор](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/Conditional_Operator) - єдиний оператор у JavaScript, який приймає три операнди. У оператора  може бути одне чи два значення, в залежності від умови. Використовує  наступний синтакс:

```javascript
умова ? значення1 : значення2
```

Якщо `умова` дорівнює true, оператор повертає `значення1`. В іншому випадку - `значення2`. Умовний оператор можна використовувати будь-де, де використовується звичайний оператор. Наприклад:

```js
var status = (age >= 18) ? 'дорослий' : 'неповнолітній';
```

Ця інструкція присвоює значення "дорослий" змінній `status`, якщо значення `age` (вік) більше чи дорівнює 18. Інакше, вона присвоює змінній `status` значення "неповнолітній".

#### Оператор кома

[Оператор кома](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/Comma_Operator) (`,`) просто обчислює обидва свої операнди та повертає значення останнього  операнда. Цей оператор найчастіше використовується всередині циклу `for`, що дозволяє оновлювати більше однієї змінної на кожному проході циклу. Наприклад, якщо `a` є двовимірним масивом з 10 елементами  по кожній стороні, наступний код використовує оператор кома, щоб оновити дві змінні одночасно. Код виводить значення діагональних елементів  масиву:

```js
for (var i = 0, j = 9; i <= j; i++, j--)
  console.log('a[' + i + '][' + j + ']= ' + a[i][j]);
```

#### Унарні оператори

Унарна операція - це операція лише з одним операндом.

##### `delete`

Оператор `delete` видаляє об'єкт, властивість об'єкта або елемент за вказаним індексом у масиві. Синтаксис наступний:

```js
delete objectName;
delete objectName.property;
delete objectName[index];
delete property; // працює лише всередині конструкції with
```

де `objectName` є іменем об'єкта, `property` - існуюча властивість, а `index` - ціле число, що вказує розташування елемента у масиві. Четверта форма працює лише всередині блоку `with` для видалення властивості об'єкта. 

Ви можете використовувати оператор `delete` для видалення змінних, оголошених неявно, але не тих, що були оголошені (оператором `var` ,`let` або `const`.

Якщо оператор `delete` відпрацьовує успішно, значенням властивості чи елемента стає `undefined`. Оператор `delete` повертає `true`, якщо операція можлива; він повертає `false`, якщо операція неможлива.

```js
x = 42;
var y = 43;
myobj = new Number();
myobj.h = 4;    // створює властивість h
delete x;       // вертає true (можна видалити властивість, оголошену неявно)
delete y;       // вертає false (не можна видалити властивість, оголошену через var)
delete Math.PI; // вертає false (не можна видаляти попередньо визначені властивості)
delete myobj.h; // вертає true (можна видалити властивість, визначену користувачем)
delete myobj;   // вертає true (можна видалити, якщо властивість оголошена неявно)
```

Коли ви видаляєте елемент масиву, це не впливає на довжину масиву. Для прикладу, якщо ви видалите `a[3]`, `a[4]` досі є `a[4]`, а `a[3]` дорівнює undefined. Коли оператор `delete` видаляє елемент масиву, цей елемент більше не існує у масиві. У наступному прикладі `trees[3]` видаляється оператором `delete`. Однак, адреса `trees[3]` досі доступна та повертає `undefined`.

```js
var trees = ['секвоя', 'лавр', 'кедр', 'дуб', 'клен'];
delete trees[3];
if (3 in trees) {
  // це не виконається
}
```

Якщо вам потрібно, щоб елемент існував, але мав значення undefined, скористайтесь ключовим словом `undefined` замість оператора `delete`. У наступному прикладі `trees[3]` присвоюється значення `undefined`, але елемент масиву досі існує:

```js
var trees = ['секвоя', 'лавр', 'кедр', 'дуб', 'клен'];
trees[3] = undefined;
if (3 in trees) {
  // це виконається
}
```

##### `typeof`

Опис `typeof` наведений [вище](#typeof)

##### `void`

Оператор [`void`](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/void) використовується наступним чином:

```
void (вираз)
void вираз
```

Оператор `void` вказує, що вираз має бути обчислений без повернення значення. `Вираз` є виразом JavaScript, який треба обчислити. Дужки, що оточують вираз, є необов'язковими, але вживати їх є гарним стилем. Наступний код створює гіпертекстове посилання, яке відправляє форму, коли користувач натискає на нього.

```html
<a href="javascript:void(document.form.submit())">
Натисніть сюди, щоб відправити</a>
```

#### Оператори відношення

Оператор відношення порівнює свої операнди та повертає значення `Boolean`, на підставі того, чи є порівняння істиною.

##### `in` (існування властивості або індекс масиву){#in}

Оператор [`in`](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/in) повертає `true`, якщо вказана властивість існує на вказаному об'єкті. Синтаксис наступний:

```js
propNameOrNumber in objectName
```

де `propNameOrNumber` є рядковим або числовим виразом, який відображає ім'я властивості або індекс у масиві, а `objectName` є ім'ям об'єкта. Наступний приклад демонструє варіанти використання оператора `in`.

```js
// --- Масиви
var trees = ['секвоя', 'лавр', 'кедр', 'дуб', 'клен'];
0 in trees;        // вертає true
3 in trees;        // вертає true
6 in trees;        // вертає false
'лавр' in trees;   // вертає false (ви маєте вказати індекс,а не значення за цим індексом)
'length' in trees; // вертає true (length є властивістю масиву)
// --- вбудовані об'єкти
'PI' in Math;          // вертає true
var myString = new String('корал');
'length' in myString;  // вертає true
// --- Користувацькі об'єкти
var mycar = { make: 'Honda', model: 'Accord', year: 1998 };
'make' in mycar;  // вертає true
'model' in mycar; // вертає true
```

##### `instanceof` (належність об'єкту до типу)

Оператор [`instanceof`](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/instanceof) повертає `true`, якщо вказаний об'єкт належить до вказаного типу. Синтаксис наступний:

```js
objectName instanceof objectType
```

де `objectName` є ім'ям об'єкта, який порівнюється з `objectType`, а `objectType` є типом об'єкта, наприклад, [`Date`](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Global_Objects/Date) або [`Array`](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Global_Objects/Array).

Використовуйте `instanceof`, коли вам необхідно  підтвердити тип об'єкта під час виконання. Наприклад, перехоплюючи  винятки, ви можете зробити відгалуження до іншого коду обробки винятків, в залежності від типу викинутого винятку. Наприклад, наступний код використовує `instanceof` для визначення того, чи `theDay` є об'єктом `Date`. Оскільки `theDay` є об'єктом `Date`, інструкції у блоці `if` будуть виконані.

```js
var theDay = new Date(1995, 12, 17);
if (theDay instanceof Date) {
  // інструкції для виконання
}
```

#### Пріоритет операторів

*Пріоритет* операторів визначає порядок, у якому вони  застосовуються під час обчислення виразу. Ви можете змінити пріоритет  оператора, використавши дужки. Наступна таблиця наводить пріоритети операторів, від найвищого до найнижчого.

| Тип оператора                 | Окремі оператори                         |
| ----------------------------- | ---------------------------------------- |
| властивість                   | `. []`                                   |
| виклик / створення екземпляра | `() new`                                 |
| заперечення / інкремент       | `! ~ - + ++ -- typeof void delete`       |
| множення / ділення            | `* / %`                                  |
| додавання / віднімання        | `+ -`                                    |
| бітовий зсув                  | `<< >> >>>`                              |
| відношення                    | `< <= > >= in instanceof`                |
| рівність                      | `== != === !==`                          |
| побітове-і                    | `&`                                      |
| виключне-побітове-або         | `^`                                      |
| побітове-або                  | `|`                                      |
| логічне-і                     | `&&`                                     |
| логічне-або                   | `||`                                     |
| умовний                       | `?:`                                     |
| присвоєння                    | `= += -= *= /= %= <<= >>= >>>= &= ^= |=` |
| кома                          | `,`                                      |

Більш детальну версію цієї таблиці, доповнену посиланнями на додаткові подробиці щодо кожного оператора, можна знайти у [довіднику з JavaScript](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/Operator_Precedence).

### Вирази

#### `this`

Використовуйте [ключове слово `this`](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/this) для посилання на поточний об'єкт. Загалом, `this` у методі посилається на об'єкт, що його викликав. Використовуйте `this` або з крапкою, або з дужковою нотацією:

```
this['propertyName']
this.propertyName
```

#### Оператор групування

Оператор групування `( )` керує пріоритетом обчислення у виразах. Наприклад, ви можете змінити обчислення спочатку множення та  ділення, а потім додавання та віднімання, щоб обчислити спочатку  додавання.

#### `new`

Ви можете скористатись [оператором `new`](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/new), щоб створити екземпляр визначеного користувачем типу об'єкта або одного з вбудованих типів. Використовуйте `new` наступним чином:

```js
var objectName = new objectType([param1, param2, ..., paramN]);
```

#### super

[Ключове слово super](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/super) використовується для виклику функцій батьківського об'єкта. Воно корисне для використання з [класами](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Classes), для виклику батьківського конструктора, наприклад.

```
super([arguments]); // викликає батьківський конструктор.
super.functionOnParent([arguments]);
```

#### Оператор розпакування (`...`)

[Оператор розпакування](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/Spread_syntax) дозволяє розкласти вираз там, де очікується більше одного аргументу (для  викликів функцій) або більше одного елемента (для масивних літералів).

**Приклад:** Сьогодні, якщо ви маєте масив та бажаєте  створити новий масив, використавши існуючий масив як його частину,  синтаксису масивного літералу більше недостатньо, і вам доводиться  повертатись до імперативного коду, використовуючи комбінацію з `push`, `splice`, `concat`, і т. д. З оператором розпакування все стає набагато лаконічнішим:

```js
var parts = ['плечі', 'коліна'];
var lyrics = ['голова', ...parts, 'та', 'пальці'];
```





#### Остаток от деления %

Оператор взятия остатка `%`, несмотря на обозначение, никакого отношения к процентам не имеет.

Его результат `a % b` – это остаток от деления `a` на `b`.

Например:

​                      

​                      

```javascript
alert( 5 % 2 ); // 1, остаток от деления 5 на 2
alert( 8 % 3 ); // 2, остаток от деления 8 на 3
alert( 6 % 3 ); // 0, остаток от деления 6 на 3
```

#### Возведение в степень **

Оператор возведения в степень `**` недавно добавили в язык.

Для натурального числа `b` результат `a ** b` равен `a`, умноженному на само себя `b` раз.

Например:

​                      

​                      

```javascript
alert( 2 ** 2 ); // 4  (2 * 2)
alert( 2 ** 3 ); // 8  (2 * 2 * 2)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)
```

Оператор работает и для нецелых чисел.

Например:

​                      

​                      

```javascript
alert( 4 ** (1/2) ); // 2 (степень 1/2 эквивалентна взятию квадратного корня)
alert( 8 ** (1/3) ); // 2 (степень 1/3 эквивалентна взятию кубического корня)
```

#### Инкремент/декремент

Одной из наиболее частых операций в JavaScript, как и во многих  других языках программирования, является увеличение или уменьшение  переменной на единицу.

Для этого существуют даже специальные операторы:

- **Инкремент** `++` увеличивает на 1:

  ​                      

  ​                      

  ```javascript
  let counter = 2;
  counter++;        // работает как counter = counter + 1, просто запись короче
  alert( counter ); // 3
  ```

**Декремент** `--` уменьшает на 1:

​                      

​                      

```javascript
let counter = 2;
counter--;        // работает как counter = counter - 1, просто запись короче
alert( counter ); // 1
```

Важно:

Инкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++, приведёт к ошибке.

Операторы `++` и `--` могут быть расположены не только после, но и до переменной.

- Когда оператор идёт после переменной – это «постфиксная форма»: `counter++`.
- «Префиксная форма» – это когда оператор идёт перед переменной: `++counter`.

Обе эти формы записи делают одно и то же: увеличивают `counter` на `1`.

Есть ли разница между ними? Да, но увидеть её мы сможем, только если будем использовать значение, которое возвращают `++/--`.

Давайте проясним этот момент. Как мы знаем, все операторы возвращают  значение. Операторы инкремент/декремент не исключение. Префиксная форма  возвращает новое значение, в то время как постфиксная форма возвращает  старое (до увеличения/уменьшения числа).

Чтобы увидеть разницу, вот небольшой пример:

​                      

​                      

```javascript
              let counter = 1;
let a = ++counter; // (*)

alert(a); // 2
```

В строке `(*)` *префиксная* форма увеличения `counter`, она возвращает новое значение `2`. Так что `alert` покажет `2`.

Теперь посмотрим на постфиксную форму:

​                      

​                      

```javascript
              let counter = 1;
let a = counter++; // (*) меняем ++counter на counter++

alert(a); // 1
```

В строке `(*)` *постфиксная* форма `counter++` также увеличивает `counter`, но возвращает *старое* значение (которое было до увеличения). Так что `alert` покажет `1`.

Подведём итоги:

- Если результат оператора не используется, а нужно только увеличить/уменьшить переменную – без разницы, какую форму использовать:

  ​                      

  ​                      

  ```javascript
  let counter = 0;
  counter++;
  ++counter;
  alert( counter ); // 2, обе строки сделали одно и то же
  ```

Если хочется тут же использовать результат, то нужна префиксная форма:

​                      

​                      

```javascript
let counter = 0;
alert( ++counter ); // 1
```

Если нужно увеличить и при этом получить значение переменной *до увеличения* – постфиксная форма:

​                      

​                      

```javascript
let counter = 0;
alert( counter++ ); // 0
```

Инкремент/декремент можно использовать в любых выражениях

Операторы `++/--` могут также использоваться внутри выражений. Их приоритет выше, чем у арифметических операций.

Например:

​                      

​                      

```javascript
let counter = 1;
alert( 2 * ++counter ); // 4
```

Сравните с:

​                      

​                      

```javascript
let counter = 1;
alert( 2 * counter++ ); // 2, потому что counter++ возвращает "старое" значение
```

Хотя технически всё в порядке, такая запись обычно делает код менее  читабельным. Одна строка выполняет множество действий – нехорошо.

При беглом чтении кода можно с лёгкостью пропустить такой `counter++`, и будет неочевидно, что переменная увеличивается.

Лучше использовать стиль «одна строка – одно действие»:

​                      

​                      

```javascript
let counter = 1;
alert( 2 * counter );
counter++;
```

#### Побитовые операторы

Побитовые операторы работают с 32-разрядными целыми числами (при необходимости  приводят к ним), на уровне их внутреннего двоичного представления.

Эти операторы не являются чем-то специфичным для JavaScript, они поддерживаются в большинстве языков программирования.

Поддерживаются следующие побитовые операторы:

- AND(и) ( `&` )
- OR(или) ( `|` )
- XOR(побитовое исключающее или) ( `^` )
- NOT(не) ( `~` )
- LEFT SHIFT(левый сдвиг) ( `<<` )
- RIGHT SHIFT(правый сдвиг) ( `>>` )
- ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( `>>>` )

Они используются редко. Чтобы понять их, нам нужно углубиться в  низкоуровневое представление чисел, и было бы неоптимально делать это  прямо сейчас, тем более что они нам не понадобятся в ближайшее время.  Если вам интересно, вы можете прочитать статью [Побитовые операторы](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators) на MDN. Практично будет сделать это, когда возникнет реальная необходимость.

#### Сокращённая арифметика с присваиванием

Часто нужно применить оператор к переменной и сохранить результат в ней же.

Например:

```javascript
let n = 2;
n = n + 5;
n = n * 2;
```

Эту запись можно укоротить при помощи совмещённых операторов `+=` и `*=`:

​                      

​                      

```javascript
let n = 2;
n += 5; // теперь n=7 (работает как n = n + 5)
n *= 2; // теперь n=14 (работает как n = n * 2)

alert( n ); // 14
```

Подобные краткие формы записи существуют для всех арифметических и побитовых операторов: `/=`, `-=` и так далее.

Вызов с присваиванием имеет в точности такой же приоритет, как  обычное присваивание, то есть выполнится после большинства других  операций:

​                      

​                      

```javascript
let n = 2;

n *= 3 + 5;

alert( n ); // 16  (сначала выполнится правая часть, превратив выражение в n *= 8)
```

#### Оператор запятая

Оператор «запятая» `,` редко используется и является одним из самых необычных. Иногда он  используется для написания более короткого кода, поэтому нам нужно знать его, чтобы понимать, что при этом происходит.

Оператор запятая предоставляет нам возможность вычислять несколько выражений, разделяя их запятой `,`. Каждое выражение выполняется, но возвращается результат только последнего.

Например:

​                      

​                      

```javascript
let a = (1 + 2, 3 + 4);

alert( a ); // 7 (результат 3 + 4)
```

Первое выражение `1 + 2` выполняется, а результат отбрасывается. Затем идёт `3 + 4`, выражение выполняется и возвращается результат.

Запятая имеет очень низкий приоритет

Пожалуйста, обратите внимание, что оператор `,` имеет очень низкий приоритет, ниже `=`, поэтому скобки важны в приведённом выше примере.

Без них в `a = 1 + 2, 3 + 4` сначала выполнится `+`, суммируя числа в `a = 3, 7`, затем оператор присваивания `=` присвоит `a = 3`, а то, что идёт дальше, будет игнорировано. Всё так же, как в `(a = 1 + 2), 3 + 4`.

Зачем нам оператор, который отбрасывает всё, кроме последнего выражения?

Иногда его используют в составе более сложных конструкций, чтобы сделать несколько действий в одной строке.

Например:

```javascript
                            // три операции в одной строке
for (a = 1, b = 3, c = a * b; a < 10; a++) {
 ...
}
```

Такие трюки используются во многих JavaScript-фреймворках. Вот почему мы  упоминаем их. Но обычно они не улучшают читабельность кода, поэтому  стоит хорошо подумать, прежде чем их использовать.

## Основні програмні структури

### Цикли `while` та `for`

Цикл **`while`** имеет следующий синтаксис:

```javascript
while (condition) {
  // код
  // также называемый "телом цикла"
}
```

Код из тела цикла выполняется, пока условие `condition` истинно. Например, цикл ниже выводит `i`, пока `i < 3`                     

```javascript
let i = 0;
while (i < 3) { // выводит 0, затем 1, затем 2
  alert( i );
  i++;
}
```

Одно выполнение тела цикла по-научному называется *итерация*. Цикл в примере выше совершает три итерации.

Если тело цикла состоит лишь из одной инструкции, мы можем опустить фигурные скобки `{…}`:                      

```javascript
let i = 3;
while (i) alert(i--);
```

Проверку условия можно разместить под телом цикла, используя специальный синтаксис **`do..while`**:

```javascript
do {
  // тело цикла
} while (condition);
```

Цикл сначала выполнит тело, а затем проверит условие `condition`, и пока его значение равно `true`, он будет выполняться снова и снова. Например:                     

```javascript
let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```

Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось **хотя бы один раз**, даже если условие окажется ложным. На практике чаще используется форма с предусловием: `while(…) {…}`.

Более сложный, но при этом самый распространённый цикл — цикл **`for`**.

```javascript
for (начало; условие; шаг) {
  // ... тело цикла ...
}
```

Цикл ниже выполняет `alert(i)` для `i` от `0` до (но не включая) `3`:  

```javascript
for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
  alert(i);
}
```

| часть     |            |                                                              |
| --------- | ---------- | ------------------------------------------------------------ |
| *начало*  | `i = 0`    | Выполняется один раз при входе в цикл                        |
| *условие* | `i < 3`    | Проверяется *перед* каждой итерацией цикла. Если оно вычислится в `false`, цикл остановится. |
| *шаг*     | `i++`      | Выполняется *после* тела цикла на каждой итерации *перед* проверкой условия. |
| *тело*    | `alert(i)` | Выполняется снова и снова, пока условие вычисляется в `true`. |

В целом, алгоритм работы цикла выглядит следующим образом:

```none
Выполнить *начало*
→ (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
→ (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
→ (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
→ ...
```

То есть, *начало* выполняется один раз, а затем каждая итерация заключается в проверке *условия*, после которой выполняется *тело* и *шаг*.

Вместо объявления новой переменной мы можем использовать уже существующую:                  

```javascript
let i = 0;
for (i = 0; i < 3; i++) { // используем существующую переменную
  alert(i); // 0, 1, 2
}
alert(i); // 3, переменная доступна, т.к. была объявлена снаружи цикла
```

**Пропуск частей `for` и `step`**

Любая часть `for` может быть пропущена. Для примера, мы можем пропустить `начало` если нам ничего не нужно делать перед стартом цикла.                      

```javascript
let i = 0; // мы уже имеем объявленную i с присвоенным значением
for (; i < 3; i++) { // нет необходимости в "начале"
  alert( i ); // 0, 1, 2
}
```

Можно убрать и `шаг`:                 

```javascript
let i = 0;
for (; i < 3;) {
  alert( i++ );
}
```

Это сделает цикл аналогичным `while (i < 3)`. А можно и вообще убрать всё, получив бесконечный цикл:

```javascript
for (;;) {
  // будет выполняться вечно
}
```

При этом сами точки с запятой `;` обязательно должны присутствовать, иначе будет ошибка синтаксиса.

**Прерывание цикла: «break»**

Обычно цикл завершается при вычислении *условия* в `false`. Но мы можем выйти из цикла в любой момент с помощью специальной директивы `break`. Например, следующий код подсчитывает сумму вводимых чисел до тех пор, пока посетитель их вводит, а затем – выдаёт:

```javascript
let sum = 0;
while (true) {
  let value = +prompt("Введите число", '');
  if (!value) break; // (*)
  sum += value;
}
alert( 'Сумма: ' + sum );
```

Директива `break` в строке `(*)` полностью прекращает выполнение цикла и передаёт управление на строку за его телом, то есть на `alert`.

**Переход к следующей итерации: continue**

Директива `continue` – «облегчённая версия» `break`. При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно `true`). Её используют, если понятно, что на текущем повторе цикла делать больше нечего.       

```javascript
 for (let i = 0; i < 10; i++) {
  // если true, пропустить оставшуюся часть тела цикла
  if (i % 2 == 0) continue;
  alert(i); // 1, затем 3, 5, 7, 9
}
```

Для чётных значений `i`, директива `continue` прекращает выполнение тела цикла и передаёт управление на следующую итерацию `for` (со следующим числом). Таким образом `alert` вызывается только для нечётных значений.

**`for..of`** Для массивов возможен и другой вариант цикла, `for..of`:                   

```javascript
let fruits = ["Яблоко", "Апельсин", "Слива"];
// проходит по значениям
for (let fruit of fruits) {
  alert( fruit );
}
```

Цикл `for..of` не предоставляет доступа к номеру текущего элемента, только к его  значению, но в большинстве случаев этого достаточно. А также это короче.

#### `for..in`{#forin}

### Оператори порівняння

[javascript.ru](https://learn.javascript.ru/comparison)

- Больше/меньше: `a > b`, `a < b`.
- Больше/меньше или равно: `a >= b`, `a <= b`.
- Равно: `a == b`. Обратите внимание, для сравнения используется двойной знак равенства `=`. Один знак равенства `a = b` означал бы присваивание.
- Не равно. В математике обозначается символом `≠`. В JavaScript записывается как знак равенства с предшествующим ему восклицательным знаком: `a != b`.

Операторы сравнения, как и другие операторы, возвращают значение. Это значение имеет логический тип.

- `true` – означает «да», «верно», «истина».
- `false` – означает «нет», «неверно», «ложь».

Например:                

```javascript
alert( 2 > 1 );  // true (верно)
alert( 2 == 1 ); // false (неверно)
alert( 2 != 1 ); // true (верно)
```

Результат сравнения можно присвоить переменной, как и любое значение:            

```javascript
let result = 5 > 4; // результат сравнения присваивается переменной result
alert( result ); // true
```

Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный» или «лексикографический» порядок. Другими словами, строки сравниваются посимвольно.

```javascript
alert( 'Я' > 'А' ); // true
alert( 'Кот' > 'Код' ); // true
alert( 'Сонный' > 'Сон' ); // true
```

При сравнении значений разных типов JavaScript приводит каждое из них к числу. Например:                     

```javascript
alert( '2' > 1 ); // true, строка '2' становится числом 2
alert( '01' == 1 ); // true, строка '01' становится числом 1
```

Логическое значение `true` становится `1`, а `false` – `0`. Например:

```javascript
alert( true == 1 ); // true
alert( false == 0 ); // true
```

Возможна следующая ситуация:

- Два значения равны.
- Одно из них `true` как логическое значение, другое – `false`.

Например:

```javascript
let a = 0;
alert( Boolean(a) ); // false
let b = "0";
alert( Boolean(b) ); // true
alert(a == b); // true!
```

С точки зрения JavaScript, результат ожидаем. Равенство преобразует значения, используя числовое преобразование, поэтому `"0"` становится `0`. В то время как явное преобразование с помощью `Boolean` использует другой набор правил.

Использование обычного сравнения `==` может вызывать проблемы. Например, оно не отличает `0` от `false`:              

```javascript
alert( 0 == false ); // true
```

Та же проблема с пустой строкой:           

```javascript
alert( '' == false ); // true
```

Это происходит из-за того, что операнды разных типов преобразуются оператором `==` к числу. В итоге, и пустая строка, и `false` становятся нулём.

**Оператор строгого равенства `===` проверяет равенство без приведения типов.**

Другими словами, если `a` и `b` имеют разные типы, то проверка `a === b` немедленно возвращает `false` без попытки их преобразования.             

```javascript
alert( 0 === false ); // false, так как сравниваются разные типы
```

Ещё есть оператор строгого неравенства `!==`, аналогичный `!=`. Оператор строгого равенства дольше писать, но он делает код более очевидным и оставляет меньше мест для ошибок.

Поведение `null` и `undefined` при сравнении с другими значениями – особое:

- При строгом равенстве `===`

  Эти значения различны, так как различны их типы.                                                                                                                 `alert( null === undefined ); // false`

При нестрогом равенстве `==` Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.                   

```javascript
alert( null == undefined ); // true
```

- При использовании математических операторов и других операторов сравнения `< > <= >=`

  Значения `null/undefined` преобразуются к числам: `null` становится `0`, а `undefined` – `NaN`.

Посмотрим, какие забавные вещи случаются, когда мы применяем эти  правила. И, что более важно, как избежать ошибок при их использовании.

Сравним `null` с нулём:

```javascript
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```

С точки зрения математики это странно. Результат последнего сравнения говорит о том, что "`null` больше или равно нулю", тогда результат одного из сравнений выше должен быть `true`, но они оба ложны.

Причина в том, что нестрогое равенство и сравнения `> < >= <=` работают по-разному. Сравнения преобразуют `null` в число, рассматривая его как `0`. Поэтому выражение (3) `null >= 0` истинно, а `null > 0` ложно.

С другой стороны, для нестрогого равенства `==` значений `undefined` и `null` действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому (2) `null == 0` ложно.

Значение `undefined` несравнимо с другими значениями:         

```javascript
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

Почему же сравнение `undefined` с нулём всегда ложно?

На это есть следующие причины:

- Сравнения `(1)` и `(2)` возвращают `false`, потому что `undefined` преобразуется в `NaN`, а `NaN` – это специальное числовое значение, которое возвращает `false` при любых сравнениях.
- Нестрогое равенство `(3)` возвращает `false`, потому что `undefined` равно только `null` и ничему больше.

Просто относитесь к любому сравнению с `undefined/null`, кроме строгого равенства `===`, с осторожностью.

Не используйте сравнения `>= > < <=` с переменными, которые могут принимать значения `null/undefined`, если вы не уверены в том, что делаете. Если переменная может принимать эти значения, то добавьте для них отдельные проверки.